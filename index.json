[{"categories":null,"content":" DBMS 需要保证 如果事务终止，不存在部分的改变 如果事务提交，所有的修改应该能够持久化 通过 undo 保证前者，通过 redo 保证后者 ","date":"2023-01-05","objectID":"/cmu15445-%E6%97%A5%E5%BF%97/:0:0","tags":["cmu15445"],"title":"cmu15445-日志","uri":"/cmu15445-%E6%97%A5%E5%BF%97/"},{"categories":null,"content":"buffer pool policies Force 事务提交时修改必须落盘 No-Steal 事务提交前修改不能落盘 ","date":"2023-01-05","objectID":"/cmu15445-%E6%97%A5%E5%BF%97/:1:0","tags":["cmu15445"],"title":"cmu15445-日志","uri":"/cmu15445-%E6%97%A5%E5%BF%97/"},{"categories":null,"content":"shadow paging 保留 master 和 shadow 两个版本，master 保留已经提交事务的修改，shadow 保存未提交事务的修改。当事务提交时，令 shadow 版本变为 master 版本。 如果每当事务提交再刷盘，则再事务提交前 buffer pool 中的页不能被替换，导致 buffer pool 满了，shadow paging 可以很好地解决这个问题。 它的缺点在于每次更新都要刷盘，同时需要垃圾回收，会产生碎片，并且只支持一个 writer。 ","date":"2023-01-05","objectID":"/cmu15445-%E6%97%A5%E5%BF%97/:2:0","tags":["cmu15445"],"title":"cmu15445-日志","uri":"/cmu15445-%E6%97%A5%E5%BF%97/"},{"categories":null,"content":"sqlite rollback mode 每次更新的时候都将原始 page 写入 journal file 中，系统崩溃时使用 journal file 进行回滚。 ","date":"2023-01-05","objectID":"/cmu15445-%E6%97%A5%E5%BF%97/:2:1","tags":["cmu15445"],"title":"cmu15445-日志","uri":"/cmu15445-%E6%97%A5%E5%BF%97/"},{"categories":null,"content":"write-ahead log 在将数据写入磁盘前，先将记录的变更情况写入日志中。如果日志成功写入，则认为该事务可以进行提交。 不应该等事务提交之后再进行日志的刷盘，最好 group commit 日志刷盘的时机： log buffer 满 超时 ","date":"2023-01-05","objectID":"/cmu15445-%E6%97%A5%E5%BF%97/:3:0","tags":["cmu15445"],"title":"cmu15445-日志","uri":"/cmu15445-%E6%97%A5%E5%BF%97/"},{"categories":null,"content":"logging schemes ","date":"2023-01-05","objectID":"/cmu15445-%E6%97%A5%E5%BF%97/:4:0","tags":["cmu15445"],"title":"cmu15445-日志","uri":"/cmu15445-%E6%97%A5%E5%BF%97/"},{"categories":null,"content":"checkpoints 暂停全部事务,进行日志和数据的刷盘 checkpoint 前已提交的事务，忽略；崩溃前未提交的事务，undo；崩溃前已提交的事务，redo ","date":"2023-01-05","objectID":"/cmu15445-%E6%97%A5%E5%BF%97/:5:0","tags":["cmu15445"],"title":"cmu15445-日志","uri":"/cmu15445-%E6%97%A5%E5%BF%97/"},{"categories":null,"content":"Uncharted 4 神秘海域作为我买来 ps5 第一个通关的游戏，其实给我带来的体验并没有完全达到预期，甚至中途迷路的时候短暂的出现了 3d 眩晕让我一度失去了继续玩下去的动力。游戏的交互主要由攀岩、跳跃、射击和小部分解谜构成，操作上的单一性导致游戏在后期给我的新鲜感逐渐降低，不过神秘海域的画面一定程度上弥补了游戏性上的不足，刚抵达拉博塔尼亚的画面着实令人眼前一亮，宛如抵达了世外桃源。 本作的剧情主要围绕内特和山姆两兄弟的寻宝征程展开，从携手逃出修道院到最终见证宝藏、死里逃生，看着两人一路上互相依靠，成为彼此的靠山，在悬崖间轻盈地荡漾，在峭壁的岩石上留下自己的足迹，我不禁回想起了自己的童年。同样也是几个哥哥带着我上房揭瓦，我们一起偷偷翻进过地坛小学的足球场在保安手下溜之大吉，也曾越过栅栏跑到一七一北校的食堂上，更有一次因为被困在房顶上不敢下来而心惊肉跳，一切都是那么的相似！ 内特虽然在最后和宝藏失之交臂但是却还有哥哥和妻子陪伴左右，而我又该怎样找到属于我自己的宝藏呢？童年的伙伴们如今跟我渐行渐远甚至完全没了联系，曾经那一个个疯癫的寒暑假也再也找回不来了，我自己在成长的道路上却逐渐失去了往日的灵性。也许只能靠脚踏实地走好今后的每一步吧，不管前路如何，都要正直地去走，不给自己留下遗憾就好了。 最近才明白不是说做一件事就一定能成功，而是越努力做才越有可能成功。静下心来，不要急功近利，勇敢地向前走。 ","date":"2022-12-27","objectID":"/%E9%9A%8F%E7%AC%94/:1:0","tags":["随笔"],"title":"随笔","uri":"/%E9%9A%8F%E7%AC%94/"},{"categories":null,"content":"Worldcup 世界杯已经过去好几天了，作为梅西的粉丝，最近一直沉浸在阿根廷的夺冠集锦和喜悦当中，但是决赛惊心动魄的过程也着实令我难忘。事实上，在姆巴佩踢进第二个进球扳平比分之后我就没敢看下去了，作为一个悲观主义者，我以为纸面实力本就略逊一筹的阿根廷即将输掉比赛再次倒在决赛的舞台上。 关掉直播躺在床上的我辗转反侧，遗憾中的同时又感到难以面对。我担心梅西再次与冠军失之交臂,又仿佛在他的身上看到了自己失败的影子，总是在关键时刻错过近在咫尺的机会。那种无力感重重地拍打在我的心头，我担心自己今后的人生也将如这场比赛一样黯淡收场。 第二天起床后的第一件事便是去看比分，6:5，赢了。短暂的惊讶过后是喜悦和感动，再之后便是一遍又一遍的循环播放进球集锦。我特别喜欢贺炜最后的解说，任何命运无论多么复杂漫长，实际上只反应于一个瞬间，那就是人们彻底醒悟自己究竟是谁的那一刻，梅西从挣扎的低谷中爬起，终于一战封神。我们为什么深爱着足球这项运动，因为它不仅展现了球员们的奋斗故事，还寄托了我们普通人平凡生活中的英雄梦想，让我们更勇敢地面对真实的生活！ ","date":"2022-12-27","objectID":"/%E9%9A%8F%E7%AC%94/:2:0","tags":["随笔"],"title":"随笔","uri":"/%E9%9A%8F%E7%AC%94/"},{"categories":null,"content":" 读不会阻塞写，写也不会阻塞读。 只读事务可以读到连续的快照并用时间戳决定可见性。 支持 time-travel 查询。 ","date":"2022-12-18","objectID":"/cmu15445-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:0:0","tags":["cmu15445"],"title":"cmu15445-多版本并发控制","uri":"/cmu15445-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"MVCC ","date":"2022-12-18","objectID":"/cmu15445-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:1:0","tags":["cmu15445"],"title":"cmu15445-多版本并发控制","uri":"/cmu15445-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"SI ","date":"2022-12-18","objectID":"/cmu15445-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:1:1","tags":["cmu15445"],"title":"cmu15445-多版本并发控制","uri":"/cmu15445-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"write skew anomaly ","date":"2022-12-18","objectID":"/cmu15445-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:1:2","tags":["cmu15445"],"title":"cmu15445-多版本并发控制","uri":"/cmu15445-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"design decisions ","date":"2022-12-18","objectID":"/cmu15445-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:2:0","tags":["cmu15445"],"title":"cmu15445-多版本并发控制","uri":"/cmu15445-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"concurrency control 2pl occ t/o ","date":"2022-12-18","objectID":"/cmu15445-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:2:1","tags":["cmu15445"],"title":"cmu15445-多版本并发控制","uri":"/cmu15445-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"version storage 使用版本链存储不同的版本。 append-only new to old 不需要遍历查找最新版本，但每次更新 tuple 都要更新索引指针 old to new 与 new to old 相反 time-travel main table 存放最新值，time-travel table 存放过去的版本 delta main table 存放最新值，delta storage segment 存放过去的版本并在 time-travel 的基础上记录 old_value-\u003enew_value ","date":"2022-12-18","objectID":"/cmu15445-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:2:2","tags":["cmu15445"],"title":"cmu15445-多版本并发控制","uri":"/cmu15445-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"garbage collection 应该被回收的版本包括： 没有活跃的事务对该版本可见 该版本由已经终止的事务创建 tuple-level background vacuuming 周期性地扫描表 使用 bitmap 记录 dirty block cooperative cleaning 在遍历版本链地时候进行清理 只适用于 O2N transaction-level 在事务终止或提交时为 vacuum worker 提供信息，DBMS 周期性判定什么时候该版本不再可见。 ","date":"2022-12-18","objectID":"/cmu15445-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:2:3","tags":["cmu15445"],"title":"cmu15445-多版本并发控制","uri":"/cmu15445-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"index management 二级索引 如何对维护二级索引地多版本信息 逻辑指针 将二级索引的 tuple id 映射至主键索引或物理地址 物理指针 二级索引指针直接指向版本链 剩余还有 duplicate key 和 delete 部分被 andy 跳过去懒得记录了 hhh ","date":"2022-12-18","objectID":"/cmu15445-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:2:4","tags":["cmu15445"],"title":"cmu15445-多版本并发控制","uri":"/cmu15445-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"T/O 时间戳的分发有三种方式 系统时间(物理时间) 逻辑时间 以上两种混合 每个对象被 W-TS(X)和 R-TS(X)标记，用于标记最后一个写/读这个对象的时间戳。 对于事务的每次操作，如果它处理了一个来自“未来”的对象，则终止这个事务并重新开始。 ","date":"2022-12-17","objectID":"/cmu15445-%E6%97%B6%E9%97%B4%E6%88%B3%E6%8E%92%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:1:0","tags":["cmu15445"],"title":"cmu15445-时间戳排序并发控制","uri":"/cmu15445-%E6%97%B6%E9%97%B4%E6%88%B3%E6%8E%92%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"reads TS(T) \u003c W-TS(X)，终止事务并重新开始 否则，允许读,更新 R-TS(X) = max(R-TS(X), TS(T)), 本地复制 X 从而保证可重复读 ","date":"2022-12-17","objectID":"/cmu15445-%E6%97%B6%E9%97%B4%E6%88%B3%E6%8E%92%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:1:1","tags":["cmu15445"],"title":"cmu15445-时间戳排序并发控制","uri":"/cmu15445-%E6%97%B6%E9%97%B4%E6%88%B3%E6%8E%92%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"writes TS(T) \u003c W-TS(X)或 TS(T) \u003c R-TS(X),终止事务并重新开始 否则，允许写并更新 W-TS(X)，本地复制 X 从而保证可重复读 ","date":"2022-12-17","objectID":"/cmu15445-%E6%97%B6%E9%97%B4%E6%88%B3%E6%8E%92%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:1:2","tags":["cmu15445"],"title":"cmu15445-时间戳排序并发控制","uri":"/cmu15445-%E6%97%B6%E9%97%B4%E6%88%B3%E6%8E%92%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"Thomas write rule 在 TS(T)仅小于 W-TS(X)的情况下，允许继续执行，但不会更新 W-TS(X)。 thomas 写规则产生的调度不满足冲突可串行化但仍然是正确的，满足视图可串行化。 ","date":"2022-12-17","objectID":"/cmu15445-%E6%97%B6%E9%97%B4%E6%88%B3%E6%8E%92%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:1:3","tags":["cmu15445"],"title":"cmu15445-时间戳排序并发控制","uri":"/cmu15445-%E6%97%B6%E9%97%B4%E6%88%B3%E6%8E%92%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"observation 需要维护不同对象的时间戳，成本高，需要对冲突少的情况进行优化 对于执行时间长的事务可能会饥饿（可能有其它事务读写导致 abort） ","date":"2022-12-17","objectID":"/cmu15445-%E6%97%B6%E9%97%B4%E6%88%B3%E6%8E%92%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:1:4","tags":["cmu15445"],"title":"cmu15445-时间戳排序并发控制","uri":"/cmu15445-%E6%97%B6%E9%97%B4%E6%88%B3%E6%8E%92%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"OCC 每个事务维护一个私有的空间，读的时候将结果拷贝至私有空间中，写的时候也只修改该空间中的内容；如果没有冲突，最终将修改结果写回数据库。 读阶段 像私有空间中读写数据 校验阶段 检查是否存在冲突 写阶段 写回数据库 ","date":"2022-12-17","objectID":"/cmu15445-%E6%97%B6%E9%97%B4%E6%88%B3%E6%8E%92%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:2:0","tags":["cmu15445"],"title":"cmu15445-时间戳排序并发控制","uri":"/cmu15445-%E6%97%B6%E9%97%B4%E6%88%B3%E6%8E%92%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"validation phase 时间戳在 validation 时确定。 forward validation 和未提交的事务比较是否冲突 backward validation 和已提交的事务比较是否冲突 下图展示的是 forward validation。 若$T_i$在$T_j$开始前完成，该调度为一个串行化调度 若$T_i$在$T_j$写之前完成，需保证 $$ Writeset(T_i) \\cap Readset(T_j) = \\emptyset $$ 若$T_i$在$T_j$读完成之前完成，需保证 $$ Writeset(T_i) \\cap Readset(T_j) = \\emptyset $$ $$ Writeset(T_i) \\cap Writeset(T_j) = \\emptyset $$ ","date":"2022-12-17","objectID":"/cmu15445-%E6%97%B6%E9%97%B4%E6%88%B3%E6%8E%92%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:2:1","tags":["cmu15445"],"title":"cmu15445-时间戳排序并发控制","uri":"/cmu15445-%E6%97%B6%E9%97%B4%E6%88%B3%E6%8E%92%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"write phase 顺序提交 使用锁保证每次只有一个事务提交 并行提交 使用细粒度的锁 对主键上锁 ","date":"2022-12-17","objectID":"/cmu15445-%E6%97%B6%E9%97%B4%E6%88%B3%E6%8E%92%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:2:2","tags":["cmu15445"],"title":"cmu15445-时间戳排序并发控制","uri":"/cmu15445-%E6%97%B6%E9%97%B4%E6%88%B3%E6%8E%92%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"observation 可以很好地处理冲突少的情况 复制数据成本较大，校验和写阶段可能产生瓶颈 中断事务的成本更大 ","date":"2022-12-17","objectID":"/cmu15445-%E6%97%B6%E9%97%B4%E6%88%B3%E6%8E%92%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:2:3","tags":["cmu15445"],"title":"cmu15445-时间戳排序并发控制","uri":"/cmu15445-%E6%97%B6%E9%97%B4%E6%88%B3%E6%8E%92%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"isolation levels ","date":"2022-12-17","objectID":"/cmu15445-%E6%97%B6%E9%97%B4%E6%88%B3%E6%8E%92%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:3:0","tags":["cmu15445"],"title":"cmu15445-时间戳排序并发控制","uri":"/cmu15445-%E6%97%B6%E9%97%B4%E6%88%B3%E6%8E%92%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"phantom problem 由于插入数据导致前后两次读结果不一致。 解决方法 重新扫描 谓词锁 锁住 where 字句查询的记录 索引锁 key-value lock:对叶子结点上锁 gap lock：对索引间的间隙上锁 key-range lock：对叶子结点和间隙都上锁 如果没有索引锁，需要对表中每一页上锁，防止查询条应对应的属性被修改，同时还要对表上锁，防止新增或删除满足条件的数据。 ","date":"2022-12-17","objectID":"/cmu15445-%E6%97%B6%E9%97%B4%E6%88%B3%E6%8E%92%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:3:1","tags":["cmu15445"],"title":"cmu15445-时间戳排序并发控制","uri":"/cmu15445-%E6%97%B6%E9%97%B4%E6%88%B3%E6%8E%92%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"weaker isolation levels 隔离级别可分为可串行化、可重复读、读已提交和读未提交。弱隔离级别可能有脏读、不可重复读和幻读问题。 不同隔离级别的实现如下图所示。 ","date":"2022-12-17","objectID":"/cmu15445-%E6%97%B6%E9%97%B4%E6%88%B3%E6%8E%92%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:3:2","tags":["cmu15445"],"title":"cmu15445-时间戳排序并发控制","uri":"/cmu15445-%E6%97%B6%E9%97%B4%E6%88%B3%E6%8E%92%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"locks ","date":"2022-11-26","objectID":"/cmu15445-%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:1:0","tags":["cmu15445"],"title":"cmu15445-两阶段锁并发控制","uri":"/cmu15445-%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"执行过程 事务申请或升级锁 lock manager 同意或拒绝 事务释放锁 lock manager 更新 lock table，记录哪些事务持有什么锁以及哪些事务正在等待锁 ","date":"2022-11-26","objectID":"/cmu15445-%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:1:1","tags":["cmu15445"],"title":"cmu15445-两阶段锁并发控制","uri":"/cmu15445-%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"锁的类型 共享锁 互斥锁 ","date":"2022-11-26","objectID":"/cmu15445-%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:1:2","tags":["cmu15445"],"title":"cmu15445-两阶段锁并发控制","uri":"/cmu15445-%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"two phase locking 每一个事务可分为扩张阶段和收缩阶段 扩张阶段：只能进行锁的申请 收缩阶段：只能进行锁的释放 ","date":"2022-11-26","objectID":"/cmu15445-%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:2:0","tags":["cmu15445"],"title":"cmu15445-两阶段锁并发控制","uri":"/cmu15445-%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"cascading aborts 两阶段锁会导致脏读（读取了未提交事务写入的数据），若写入数据的事务 abort，则会发生级联回滚，即所有读取该数据的事务均会撤销。 ","date":"2022-11-26","objectID":"/cmu15445-%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:2:1","tags":["cmu15445"],"title":"cmu15445-两阶段锁并发控制","uri":"/cmu15445-%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"strict two phase locking 为解决级联回滚的问题，采用强/严格两阶段锁协议，保证事务提交之后才能够释放锁。 ","date":"2022-11-26","objectID":"/cmu15445-%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:2:2","tags":["cmu15445"],"title":"cmu15445-两阶段锁并发控制","uri":"/cmu15445-%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"conclusion ","date":"2022-11-26","objectID":"/cmu15445-%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:2:3","tags":["cmu15445"],"title":"cmu15445-两阶段锁并发控制","uri":"/cmu15445-%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"deadlocks ","date":"2022-11-26","objectID":"/cmu15445-%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:3:0","tags":["cmu15445"],"title":"cmu15445-两阶段锁并发控制","uri":"/cmu15445-%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"detection 通过等待图进行死锁检测。 ","date":"2022-11-26","objectID":"/cmu15445-%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:3:1","tags":["cmu15445"],"title":"cmu15445-两阶段锁并发控制","uri":"/cmu15445-%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"handling 选择一个受害者重新开始或者直接终止。 如何选取受害者？ 可以根据时间戳、事务执行进度、上锁的数量、导致级联删除的个数 需要防止饥饿 回滚长度？ 全部回滚，终止事务 部分回滚之 save point，然后重新执行剩下的部分 ","date":"2022-11-26","objectID":"/cmu15445-%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:3:2","tags":["cmu15445"],"title":"cmu15445-两阶段锁并发控制","uri":"/cmu15445-%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"prevention 使所有事务均遵循同样的逻辑阻塞或者终止。 时间戳越老，优先级越高 两种策略 wait-die(old waits for young) wound-wait(young waits for old) ","date":"2022-11-26","objectID":"/cmu15445-%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:3:3","tags":["cmu15445"],"title":"cmu15445-两阶段锁并发控制","uri":"/cmu15445-%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"lock granularity ","date":"2022-11-26","objectID":"/cmu15445-%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:4:0","tags":["cmu15445"],"title":"cmu15445-两阶段锁并发控制","uri":"/cmu15445-%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"hierarchy ","date":"2022-11-26","objectID":"/cmu15445-%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:4:1","tags":["cmu15445"],"title":"cmu15445-两阶段锁并发控制","uri":"/cmu15445-%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"intention locks IS 更低级别被上了共享锁 IX 更低级别被上了互斥锁 SIX S+IX 上锁原则 想要加 S、IS 锁，必须检查父结点是否添加了 IS 锁 想要加 X、IX、SIX 锁，必须检查父节点是否添加了 IX 锁 ","date":"2022-11-26","objectID":"/cmu15445-%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:4:2","tags":["cmu15445"],"title":"cmu15445-两阶段锁并发控制","uri":"/cmu15445-%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"transactions ","date":"2022-11-26","objectID":"/cmu15445-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/:1:0","tags":["cmu15445"],"title":"cmu15445-并发控制原理","uri":"/cmu15445-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"定义 对于数据库执行的一系列读写操作，是改变数据库的基本单元。 ","date":"2022-11-26","objectID":"/cmu15445-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/:1:1","tags":["cmu15445"],"title":"cmu15445-并发控制原理","uri":"/cmu15445-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"正确性标准 原子性：所有操作要么全部成功，要么全部失败 一致性：事务执行后最终的结果是正确的 隔离性：不同事务间是独立执行的 持久性：只要事务提交了，结果便可以持久生效 ","date":"2022-11-26","objectID":"/cmu15445-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/:1:2","tags":["cmu15445"],"title":"cmu15445-并发控制原理","uri":"/cmu15445-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"atomicity ","date":"2022-11-26","objectID":"/cmu15445-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/:2:0","tags":["cmu15445"],"title":"cmu15445-并发控制原理","uri":"/cmu15445-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"logging 记录所有终止事务的操作，回退该事务的全部操作 ","date":"2022-11-26","objectID":"/cmu15445-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/:2:1","tags":["cmu15445"],"title":"cmu15445-并发控制原理","uri":"/cmu15445-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"shadow paging DBMS 先复制 pages，并且对这些 pages 进行修改，再事务提交后，使这些 pages 对用户可见 ","date":"2022-11-26","objectID":"/cmu15445-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/:2:2","tags":["cmu15445"],"title":"cmu15445-并发控制原理","uri":"/cmu15445-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"consistency 始终可以保证数据库的约束，从一个正确的状态迁移至另一个正确的状态。 ","date":"2022-11-26","objectID":"/cmu15445-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/:3:0","tags":["cmu15445"],"title":"cmu15445-并发控制原理","uri":"/cmu15445-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"isolation 不同事务看起来只有它自己在执行，但事实上可能是不同事务交错执行。 两种协议： 悲观：不让冲突发生 乐观：可以发生冲突，发生冲突后解决冲突 ","date":"2022-11-26","objectID":"/cmu15445-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/:4:0","tags":["cmu15445"],"title":"cmu15445-并发控制原理","uri":"/cmu15445-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"如何判断正确性 serial schedule：依次串行执行每个事务 serializable schedule：与 serial schedule 等价的执行安排 如果是 serializable schedule，则该安排是正确的。 ","date":"2022-11-26","objectID":"/cmu15445-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/:4:1","tags":["cmu15445"],"title":"cmu15445-并发控制原理","uri":"/cmu15445-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"冲突 冲突类型 读写冲突 不可重复读 写读冲突 脏读 写写冲突 覆盖未提交的数据 冲突串行化 如果可以通过交换连续的不冲突的操作，使该 schedule 与 serial schedule 一致，则这个 schedule 是 conflit serializable 的。 更好的方法：构造优先图，如果没有环，则可以冲突串行化。 有可能不满足冲突串行化，但依然可以返回正确的结果。 视图串行化 定义： 例子： ","date":"2022-11-26","objectID":"/cmu15445-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/:4:2","tags":["cmu15445"],"title":"cmu15445-并发控制原理","uri":"/cmu15445-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"总结 各种串行化间的关系。 ","date":"2022-11-26","objectID":"/cmu15445-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/:4:3","tags":["cmu15445"],"title":"cmu15445-并发控制原理","uri":"/cmu15445-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"durability 可以通过 logging 或 shadow paging 实现。 ","date":"2022-11-26","objectID":"/cmu15445-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/:5:0","tags":["cmu15445"],"title":"cmu15445-并发控制原理","uri":"/cmu15445-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"architecture logical plan vs physical plan(?) ","date":"2022-11-17","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/:1:0","tags":["cmu15445"],"title":"cmu15445-查询计划与优化","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"heuristics optimization ","date":"2022-11-17","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/:2:0","tags":["cmu15445"],"title":"cmu15445-查询计划与优化","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"selection 尽早地执行过滤 对谓词重新排序，优先执行区分度高的 分解谓词并下推 ","date":"2022-11-17","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/:2:1","tags":["cmu15445"],"title":"cmu15445-查询计划与优化","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"projection 尽早地执行投影操作，需要保留一些字段，比如用来连接地属性。 ","date":"2022-11-17","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/:2:2","tags":["cmu15445"],"title":"cmu15445-查询计划与优化","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"others 去除不可能或不必要的谓词，谓词合并等。 ","date":"2022-11-17","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/:2:3","tags":["cmu15445"],"title":"cmu15445-查询计划与优化","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"plan cost estimation ","date":"2022-11-17","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/:3:0","tags":["cmu15445"],"title":"cmu15445-查询计划与优化","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"statistics DBMS 存储了关于表、属性和索引的统计信息。 对于关系 R，DBMS 存储了关系 R 中 tuple 的数量$N_R$和每个属性 A 有多少了不同的值$V(A,R)$。 $SC(A,R)=N_R / V(A,R)$表示平均有多少 tuple 是同一个 value。 ","date":"2022-11-17","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/:3:1","tags":["cmu15445"],"title":"cmu15445-查询计划与优化","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"selections(不同谓词的选择性) $$sel(A=constant) = SC(P) / N_R = 1 / V(A,R)$$ $$sel(A\u003e=a) = (A_{max}-a) / (A_{max}-A_{min})$$ $$sel(not P) = a - sel(P)$$ $$sel(P_1 ⋀ P_2) = sel(P_1) * sel(P_2)$$ $$sel(P_1 ⋁ P_2) = sel(P_1) + sel(P_2) - sel(P_1) * sel(P_2)$$ ","date":"2022-11-17","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/:3:2","tags":["cmu15445"],"title":"cmu15445-查询计划与优化","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"assumption 数据均匀分布 不同的筛选条件是独立的 内表中的 key 总能在外表中找到(?) 然而数据的分布不总是均匀的，需要通过改变 bucket 的“宽度”，使得不同 bucket 数据接近均匀分布。 除此之外，不同筛选条件也未必是独立的，而是相互关联的。 ","date":"2022-11-17","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/:3:3","tags":["cmu15445"],"title":"cmu15445-查询计划与优化","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"sampling 使用抽样的方式估测不同属性的选择性。当表大幅度改变时，需要更新样本。 ","date":"2022-11-17","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/:3:4","tags":["cmu15445"],"title":"cmu15445-查询计划与优化","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"plan enumeration ","date":"2022-11-17","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/:4:0","tags":["cmu15445"],"title":"cmu15445-查询计划与优化","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"single-relation query planning 顺序扫描 二分查找（对于聚集索引） 索引扫描 从三者中选择最好的 access method 即可，可以进行一定的启发式优化。 ","date":"2022-11-17","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/:4:1","tags":["cmu15445"],"title":"cmu15445-查询计划与优化","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"multi-relation query planning System-R only consider left-deep, usually pipelined, no temp files dynamic programming 枚举 join 顺序 - 枚举不同算子使用的算法 - 枚举 access methods ","date":"2022-11-17","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/:4:2","tags":["cmu15445"],"title":"cmu15445-查询计划与优化","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"postgres optimizer 连接数量少于 12 时，使用 system-r，否则使用 GEQO。 GEQO:最开始随机生成 query planning，舍弃代价最大的算法，随机反转其余的。 ","date":"2022-11-17","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/:4:3","tags":["cmu15445"],"title":"cmu15445-查询计划与优化","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"nested sub-queries ","date":"2022-11-17","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/:5:0","tags":["cmu15445"],"title":"cmu15445-查询计划与优化","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"rewrite 重写 sql，去除嵌套关系。 ","date":"2022-11-17","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/:5:1","tags":["cmu15445"],"title":"cmu15445-查询计划与优化","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"decompose 先单独执行子查询，将查询结果写入临时文件，执行外层查询时，用临时的结果替换内层查询。 ","date":"2022-11-17","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/:5:2","tags":["cmu15445"],"title":"cmu15445-查询计划与优化","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"processing model ","date":"2022-11-16","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/:1:0","tags":["cmu15445"],"title":"cmu15445-查询执行","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/"},{"categories":null,"content":"iterator model 实现了 next 函数，每个算子通过 next 从它的孩子获取 tuple，并进行进一步的处理 每次调用，返回一个 tuple 或 null tuple breaker: join,subquery,order by 会使 pipeline 阻塞，因为它们需要全部的数据 ","date":"2022-11-16","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/:1:1","tags":["cmu15445"],"title":"cmu15445-查询执行","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/"},{"categories":null,"content":"materialization model 一次性返回全部结果 可以提供额外的信息从而避免扫描过多的 tuples 返回值可以是行也可以是列 适用于 OLTP，函数调用次数少 不适用于 OLAP，无法立即返回结果 ","date":"2022-11-16","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/:1:2","tags":["cmu15445"],"title":"cmu15445-查询执行","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/"},{"categories":null,"content":"vectorized/batch model 与 iterator 模型类似，但每次返回多组结果 ","date":"2022-11-16","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/:1:3","tags":["cmu15445"],"title":"cmu15445-查询执行","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/"},{"categories":null,"content":"access methods ","date":"2022-11-16","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/:2:0","tags":["cmu15445"],"title":"cmu15445-查询执行","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/"},{"categories":null,"content":"sequential scan 依次遍历 pages 和 tables ","date":"2022-11-16","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/:2:1","tags":["cmu15445"],"title":"cmu15445-查询执行","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/"},{"categories":null,"content":"optimizations zone map 维护表中的一些聚集值，线性扫描前首先查 zone map 进一步决定是否要进行扫描 late materialization 孩子结点只向上传递偏移量，最终在根节点再返回 tuple heap clustering 使用聚簇索引可以顺序取 pages ","date":"2022-11-16","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/:2:2","tags":["cmu15445"],"title":"cmu15445-查询执行","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/"},{"categories":null,"content":"index scan 选择区分度更高的索引 ","date":"2022-11-16","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/:2:3","tags":["cmu15445"],"title":"cmu15445-查询执行","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/"},{"categories":null,"content":"multi-index scan 依次使用每个索引筛选出 id 对根据不同索引筛选出来的集合求并集或交集 取回刚刚的结果，继续执行其它的谓词 ","date":"2022-11-16","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/:2:4","tags":["cmu15445"],"title":"cmu15445-查询执行","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/"},{"categories":null,"content":"index scan page sorting 扫描非聚簇索引是低效的，可以获取所有需要访问的 page，然后根据 page id 进行排序 ","date":"2022-11-16","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/:2:5","tags":["cmu15445"],"title":"cmu15445-查询执行","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/"},{"categories":null,"content":"expression evaluation 构建表达式树比较慢，更好的方法是直接比较 ","date":"2022-11-16","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/:3:0","tags":["cmu15445"],"title":"cmu15445-查询执行","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/"},{"categories":null,"content":"parallel processing models ","date":"2022-11-16","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/:4:0","tags":["cmu15445"],"title":"cmu15445-查询执行","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/"},{"categories":null,"content":"process per worker 基于操作系统调度 需要共享内存 一个进程挂了不会导致系统崩溃 ","date":"2022-11-16","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/:4:1","tags":["cmu15445"],"title":"cmu15445-查询执行","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/"},{"categories":null,"content":"process pool 基于操作系统调度 需要共享内存 一个进程挂了不会导致系统崩溃 CPU 缓存局部性差 ","date":"2022-11-16","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/:4:2","tags":["cmu15445"],"title":"cmu15445-查询执行","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/"},{"categories":null,"content":"thread per worker 不需要操作系统调度和共享内存 线程挂了可能导致系统崩溃 ","date":"2022-11-16","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/:4:3","tags":["cmu15445"],"title":"cmu15445-查询执行","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/"},{"categories":null,"content":"query parallelism ","date":"2022-11-16","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/:5:0","tags":["cmu15445"],"title":"cmu15445-查询执行","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/"},{"categories":null,"content":"intra query 并发地执行算子。对于 grace hash join 而言，而已为每一个 partition 分配一个线程来执行 probe。 intra-operator(horizontal) 每一个 worker 并发地执行不同 pages。 exchange算子的作用 聚集 将多个 worker 的输出整合为一个输出 重新分区 重新组织多个输出 拆分 将输入拆分成多组输出 inter-operator(vertical) 不同的 worker 并发地执行不同算子。 bushy intra-operator 的扩展，可以并发地执行查询计划的不同的算子,但依然需要 exchange 算子。 ","date":"2022-11-16","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/:5:1","tags":["cmu15445"],"title":"cmu15445-查询执行","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/"},{"categories":null,"content":"inter query 并发地执行查询。 ","date":"2022-11-16","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/:5:2","tags":["cmu15445"],"title":"cmu15445-查询执行","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/"},{"categories":null,"content":"io parallelism 一个数据库对应多个磁盘 一个磁盘队医一个数据库 一个磁盘对应一个关系 将关系拆分到多个磁盘上 ","date":"2022-11-16","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/:6:0","tags":["cmu15445"],"title":"cmu15445-查询执行","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/"},{"categories":null,"content":"multi-disk parallelism RAID，管理多个物理存储设备，可以将其看作一整个逻辑存储设备。 ","date":"2022-11-16","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/:7:0","tags":["cmu15445"],"title":"cmu15445-查询执行","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/"},{"categories":null,"content":"partitioning 将数据库表单独划分在不同的物理段上。 ","date":"2022-11-16","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/:8:0","tags":["cmu15445"],"title":"cmu15445-查询执行","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/"},{"categories":null,"content":"vertical partioning 按列分区,如何恢复？ ","date":"2022-11-16","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/:8:1","tags":["cmu15445"],"title":"cmu15445-查询执行","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/"},{"categories":null,"content":"horizontal partitioning 按行分区 哈希 按范围 按谓词 ","date":"2022-11-16","objectID":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/:8:2","tags":["cmu15445"],"title":"cmu15445-查询执行","uri":"/cmu15445-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/"},{"categories":null,"content":"join 算子输出 取决于执行、存储模型和查询本身 可以返回整个 tuple，也可以只返回 record id ","date":"2022-11-15","objectID":"/cmu15445-%E8%BF%9E%E6%8E%A5%E7%AE%97%E6%B3%95/:1:0","tags":["cmu15445"],"title":"cmu15445-连接算法","uri":"/cmu15445-%E8%BF%9E%E6%8E%A5%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"连接算法 ","date":"2022-11-15","objectID":"/cmu15445-%E8%BF%9E%E6%8E%A5%E7%AE%97%E6%B3%95/:2:0","tags":["cmu15445"],"title":"cmu15445-连接算法","uri":"/cmu15445-%E8%BF%9E%E6%8E%A5%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"nested loop join stupid nested loop join io次数：M+(m*N) block nested loop join io次数：M+(M/B*N) index nested loop join io次数：M+(m*C) ","date":"2022-11-15","objectID":"/cmu15445-%E8%BF%9E%E6%8E%A5%E7%AE%97%E6%B3%95/:2:1","tags":["cmu15445"],"title":"cmu15445-连接算法","uri":"/cmu15445-%E8%BF%9E%E6%8E%A5%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"sort-merge join outer table 可能需要回溯 io 次数：排序+合并,合并次数约为 M+N(因为回溯的存在) ","date":"2022-11-15","objectID":"/cmu15445-%E8%BF%9E%E6%8E%A5%E7%AE%97%E6%B3%95/:2:2","tags":["cmu15445"],"title":"cmu15445-连接算法","uri":"/cmu15445-%E8%BF%9E%E6%8E%A5%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"hash join 算法 使用 outer table 构建哈希表 对 inner table 的每一条 tuple 哈希，并查看是否匹配 哈希表内容 key: 连接字段 value:tuple/tuple id 优化 使用布隆过滤器,inner tuple 先查布隆过滤器，再查 hash table ","date":"2022-11-15","objectID":"/cmu15445-%E8%BF%9E%E6%8E%A5%E7%AE%97%E6%B3%95/:2:3","tags":["cmu15445"],"title":"cmu15445-连接算法","uri":"/cmu15445-%E8%BF%9E%E6%8E%A5%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"grace hash join 适用于内存不足的情况，无法容纳整个 hash table 对 inner 和 outer table 均进行哈希，分别构建 paritition, 分别构建是为了避免随机 io 对相对应的两个 partition 进行查看 tuple 是否匹配(nested loop join) 如果 一个 hash value 对应的 partition 过多，则使用新的哈希函数递归地分区 io 次数 partition:2*(M+N) probe:(M+N) ","date":"2022-11-15","objectID":"/cmu15445-%E8%BF%9E%E6%8E%A5%E7%AE%97%E6%B3%95/:2:4","tags":["cmu15445"],"title":"cmu15445-连接算法","uri":"/cmu15445-%E8%BF%9E%E6%8E%A5%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"query plan 算子按照树形结构组织 数据从叶子结点流向根结点 根节点输出最终的查询结果 不能假设查询结果都能放在内存当中，需要借助 buffer pool，并尽可能使用顺序 io ","date":"2022-11-15","objectID":"/cmu15445-%E6%8E%92%E5%BA%8F%E4%B8%8E%E8%81%9A%E9%9B%86/:1:0","tags":["cmu15445"],"title":"cmu15445-排序与聚集","uri":"/cmu15445-%E6%8E%92%E5%BA%8F%E4%B8%8E%E8%81%9A%E9%9B%86/"},{"categories":null,"content":"external merge sort ","date":"2022-11-15","objectID":"/cmu15445-%E6%8E%92%E5%BA%8F%E4%B8%8E%E8%81%9A%E9%9B%86/:2:0","tags":["cmu15445"],"title":"cmu15445-排序与聚集","uri":"/cmu15445-%E6%8E%92%E5%BA%8F%E4%B8%8E%E8%81%9A%E9%9B%86/"},{"categories":null,"content":"为什么要排序？ 加速去重(distinct) 加速聚集(group by) 构建 b+树索引更加高效 ","date":"2022-11-15","objectID":"/cmu15445-%E6%8E%92%E5%BA%8F%E4%B8%8E%E8%81%9A%E9%9B%86/:2:1","tags":["cmu15445"],"title":"cmu15445-排序与聚集","uri":"/cmu15445-%E6%8E%92%E5%BA%8F%E4%B8%8E%E8%81%9A%E9%9B%86/"},{"categories":null,"content":"2-way buffer pool size = 3 即可，因为每次只能比较两个 pages ","date":"2022-11-15","objectID":"/cmu15445-%E6%8E%92%E5%BA%8F%E4%B8%8E%E8%81%9A%E9%9B%86/:2:2","tags":["cmu15445"],"title":"cmu15445-排序与聚集","uri":"/cmu15445-%E6%8E%92%E5%BA%8F%E4%B8%8E%E8%81%9A%E9%9B%86/"},{"categories":null,"content":"double buffering 优化 提前将接下来要排序或合并的 page 加载到另一个 buffer pool 当中 可以减少 io 等待时间 ","date":"2022-11-15","objectID":"/cmu15445-%E6%8E%92%E5%BA%8F%E4%B8%8E%E8%81%9A%E9%9B%86/:2:3","tags":["cmu15445"],"title":"cmu15445-排序与聚集","uri":"/cmu15445-%E6%8E%92%E5%BA%8F%E4%B8%8E%E8%81%9A%E9%9B%86/"},{"categories":null,"content":"io 次数 ","date":"2022-11-15","objectID":"/cmu15445-%E6%8E%92%E5%BA%8F%E4%B8%8E%E8%81%9A%E9%9B%86/:2:4","tags":["cmu15445"],"title":"cmu15445-排序与聚集","uri":"/cmu15445-%E6%8E%92%E5%BA%8F%E4%B8%8E%E8%81%9A%E9%9B%86/"},{"categories":null,"content":"using b+ trees for sorting 只需要顺序扫描叶子结点 聚集索引 - 非聚集索引 - 顺序扫描非聚集索引会导致随机 io，效率很低 ","date":"2022-11-15","objectID":"/cmu15445-%E6%8E%92%E5%BA%8F%E4%B8%8E%E8%81%9A%E9%9B%86/:3:0","tags":["cmu15445"],"title":"cmu15445-排序与聚集","uri":"/cmu15445-%E6%8E%92%E5%BA%8F%E4%B8%8E%E8%81%9A%E9%9B%86/"},{"categories":null,"content":"aggregations ","date":"2022-11-15","objectID":"/cmu15445-%E6%8E%92%E5%BA%8F%E4%B8%8E%E8%81%9A%E9%9B%86/:4:0","tags":["cmu15445"],"title":"cmu15445-排序与聚集","uri":"/cmu15445-%E6%8E%92%E5%BA%8F%E4%B8%8E%E8%81%9A%E9%9B%86/"},{"categories":null,"content":"通过排序聚集 经过排序后的数据一定是按属性聚集的。 ","date":"2022-11-15","objectID":"/cmu15445-%E6%8E%92%E5%BA%8F%E4%B8%8E%E8%81%9A%E9%9B%86/:4:1","tags":["cmu15445"],"title":"cmu15445-排序与聚集","uri":"/cmu15445-%E6%8E%92%E5%BA%8F%E4%B8%8E%E8%81%9A%E9%9B%86/"},{"categories":null,"content":"通过哈希聚集 如何不需要数据有序，仅需要聚集，则哈希是个更好的方案，复杂度更低 步骤 partition 根据哈希值将 tuple 放到对应的 bucket 中 如果内存满了则写磁盘 rehash 为每个分区构建单独的哈希表，并进行聚集 partition rehash 对于每一个分区： 使用一个新的哈希函数构建哈希表 遍历每一个 bucket，将聚集匹配项 这里的前提假设是每一个分区都能存在内存当中 hashing summarization 以 k-v 对的形式存储，value 由聚集函数决定，如下图所示。 ","date":"2022-11-15","objectID":"/cmu15445-%E6%8E%92%E5%BA%8F%E4%B8%8E%E8%81%9A%E9%9B%86/:4:2","tags":["cmu15445"],"title":"cmu15445-排序与聚集","uri":"/cmu15445-%E6%8E%92%E5%BA%8F%E4%B8%8E%E8%81%9A%E9%9B%86/"},{"categories":null,"content":"concurrency control 逻辑上，能够提供正确的数值和结果 物理上，能够正确维护内部的数据结构 ","date":"2022-11-14","objectID":"/cmu15445-%E7%B4%A2%E5%BC%95%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:1:0","tags":["cmu15445"],"title":"cmu15445-索引并发控制","uri":"/cmu15445-%E7%B4%A2%E5%BC%95%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"latch overview ","date":"2022-11-14","objectID":"/cmu15445-%E7%B4%A2%E5%BC%95%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:2:0","tags":["cmu15445"],"title":"cmu15445-索引并发控制","uri":"/cmu15445-%E7%B4%A2%E5%BC%95%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"locks vs latches locks 事务层面，需要回滚数据 可以通过等待、超时、终止等机制进行死锁检测和消除 一个事务期间可以有多个线程同时访问 latch 线程层面，保护临界区中的数据结构 只能依靠程序员避免死锁 ","date":"2022-11-14","objectID":"/cmu15445-%E7%B4%A2%E5%BC%95%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:2:1","tags":["cmu15445"],"title":"cmu15445-索引并发控制","uri":"/cmu15445-%E7%B4%A2%E5%BC%95%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"latch 实现 os mutex std::mutex testandset-spin-lock 单独一条指令 std::mutex 读写锁 ","date":"2022-11-14","objectID":"/cmu15445-%E7%B4%A2%E5%BC%95%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:2:2","tags":["cmu15445"],"title":"cmu15445-索引并发控制","uri":"/cmu15445-%E7%B4%A2%E5%BC%95%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"hash table hashing 每次只访问单一 page 不会依赖其它 page，因此不会死锁。当需要改变哈希表容量时，对整张哈希表上一个全局锁。 page latch,元数据占用更少的空间 slot latch，并发度更高 ","date":"2022-11-14","objectID":"/cmu15445-%E7%B4%A2%E5%BC%95%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/:3:0","tags":["cmu15445"],"title":"cmu15445-索引并发控制","uri":"/cmu15445-%E7%B4%A2%E5%BC%95%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"hash functions 对于数据库而言，一般不适用密码学中的哈希函数，同时还要保证效率和冲突率，常用的一些哈希函数如下图所示。 ","date":"2022-10-30","objectID":"/cmu15445-%E5%93%88%E5%B8%8C%E8%A1%A8/:1:0","tags":["cmu15445"],"title":"cmu15445-哈希表","uri":"/cmu15445-%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":null,"content":"static hashing schemes ","date":"2022-10-30","objectID":"/cmu15445-%E5%93%88%E5%B8%8C%E8%A1%A8/:2:0","tags":["cmu15445"],"title":"cmu15445-哈希表","uri":"/cmu15445-%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":null,"content":"线性探测哈希 插入时如果遇到冲突，则继续寻找下一个 slot，直至找到了空 slot 由于存在冲突的情况，查询时需要线性扫描 删除时需要设置墓碑或移动后面的元素，防止无法查询到 key 重复的 key k/v 分离存储，通过指针指向 key 值对应的全部 value k/v 存储在一起，允许出现重复的 key ","date":"2022-10-30","objectID":"/cmu15445-%E5%93%88%E5%B8%8C%E8%A1%A8/:2:1","tags":["cmu15445"],"title":"cmu15445-哈希表","uri":"/cmu15445-%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":null,"content":"罗宾汉哈希 额外存放 key 实际存放位置与原始位置的偏移量 为了防止一个 key 距离其原始位置过远，应在插入时比较偏移量并进行位置上的调整 ","date":"2022-10-30","objectID":"/cmu15445-%E5%93%88%E5%B8%8C%E8%A1%A8/:2:2","tags":["cmu15445"],"title":"cmu15445-哈希表","uri":"/cmu15445-%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":null,"content":"布谷鸟哈希 使用两张哈希表，每次将 key 放在不引起冲突的表中，如果冲突不可避免，则替换其中一个 key，然后对被替换的 key 重新哈希 可能会陷入死循环 ","date":"2022-10-30","objectID":"/cmu15445-%E5%93%88%E5%B8%8C%E8%A1%A8/:2:3","tags":["cmu15445"],"title":"cmu15445-哈希表","uri":"/cmu15445-%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":null,"content":"总结 对于静态哈希，需要 DBMS 提前知道哈希表的大小，否则需要重建哈希表。 ","date":"2022-10-30","objectID":"/cmu15445-%E5%93%88%E5%B8%8C%E8%A1%A8/:2:4","tags":["cmu15445"],"title":"cmu15445-哈希表","uri":"/cmu15445-%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":null,"content":"dynamic hashing schemes ","date":"2022-10-30","objectID":"/cmu15445-%E5%93%88%E5%B8%8C%E8%A1%A8/:3:0","tags":["cmu15445"],"title":"cmu15445-哈希表","uri":"/cmu15445-%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":null,"content":"链式哈希 每个 slot 维护不同的 bucket，使用指针将其串起来。 ","date":"2022-10-30","objectID":"/cmu15445-%E5%93%88%E5%B8%8C%E8%A1%A8/:3:1","tags":["cmu15445"],"title":"cmu15445-哈希表","uri":"/cmu15445-%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":null,"content":"可扩展哈希 防止链表一直增长 多个指针可能指向同一个 bucket，需要动态调整 查询、插入时使用 glbal counter 找到 key 所在的 bucket 如果插入时 bucket 已满，则增加 local counter,并分裂 bucket ","date":"2022-10-30","objectID":"/cmu15445-%E5%93%88%E5%B8%8C%E8%A1%A8/:3:2","tags":["cmu15445"],"title":"cmu15445-哈希表","uri":"/cmu15445-%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":null,"content":"线性哈希 当一个 bucket 溢出时，不一定分裂该 bucket，而是分裂指针指向的 bucket 如何分裂？使用第二个哈希函数 使用多个哈希函数寻找 key 对应的 bucket,先使用第一个函数进行哈希，然后根据哈希后对应的 bucket 是否经历过分裂决定是否使用第二个哈希函数找到 bucket 删除时可以回退指针 当指针到达底部时（即每个 bucket 都经历过分裂后），可以删除第一个哈希函数 ","date":"2022-10-30","objectID":"/cmu15445-%E5%93%88%E5%B8%8C%E8%A1%A8/:3:3","tags":["cmu15445"],"title":"cmu15445-哈希表","uri":"/cmu15445-%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":null,"content":"buffer pool manager 数据库文件以页的形式放在磁盘上，将它们放到物理内存帧之后，为了记录 page-frame 之间的关系，需要页表来进行记录 页表中的表项还带有一些标记，比如 pin counter 和 dirty dirty: 该页被修改 pin counter: 正在访问该页的线程个数 ","date":"2022-10-22","objectID":"/cmu15445-%E7%BC%93%E5%86%B2%E6%B1%A0/:1:0","tags":["cmu15445"],"title":"cmu15445-缓冲池","uri":"/cmu15445-%E7%BC%93%E5%86%B2%E6%B1%A0/"},{"categories":null,"content":"buffer pool 的优化 multiple buffer pool 可以每个数据库配一个缓冲池，用于减少锁竞争，提高局部性。 使用 objectId(tuple 的一个隐藏字段) hash pre-fetching 基于执行计划 提前知道了数据库要访问哪些 page，并放入缓冲池，这样实际需要它们的时候就可以直接访问到了 scan sharing 让不同 cursor 同步“推进”，从而复用 buffer pool 当中的数据。 buffer pool bypass 在运行 query 的时候临时分配一段内存，数据不存放到 buffer pool 中，而是存在这段内存当中里 为什么要绕过 os page cache? 多余的 page 备份 不同的替换策略 ","date":"2022-10-22","objectID":"/cmu15445-%E7%BC%93%E5%86%B2%E6%B1%A0/:1:1","tags":["cmu15445"],"title":"cmu15445-缓冲池","uri":"/cmu15445-%E7%BC%93%E5%86%B2%E6%B1%A0/"},{"categories":null,"content":"replacement policies ","date":"2022-10-22","objectID":"/cmu15445-%E7%BC%93%E5%86%B2%E6%B1%A0/:2:0","tags":["cmu15445"],"title":"cmu15445-缓冲池","uri":"/cmu15445-%E7%BC%93%E5%86%B2%E6%B1%A0/"},{"categories":null,"content":"LRU 维护 timestamp，每次移除具有最老 timestamp 的数据 ","date":"2022-10-22","objectID":"/cmu15445-%E7%BC%93%E5%86%B2%E6%B1%A0/:2:1","tags":["cmu15445"],"title":"cmu15445-缓冲池","uri":"/cmu15445-%E7%BC%93%E5%86%B2%E6%B1%A0/"},{"categories":null,"content":"clock 维护 reference bit，当该页被访问时，将 bit 置 1 淘汰时，将 1 变成 0，如果本来就是 0，则直接淘汰 ","date":"2022-10-22","objectID":"/cmu15445-%E7%BC%93%E5%86%B2%E6%B1%A0/:2:2","tags":["cmu15445"],"title":"cmu15445-缓冲池","uri":"/cmu15445-%E7%BC%93%E5%86%B2%E6%B1%A0/"},{"categories":null,"content":"更好的策略 LRU 和 clock 的问题 容易收到 sequntial flooding 的影响，即如果 buffer pool 中依次把每个 page 都拿进来，而这些 page 很有可能只被访问这一次，之后不会再被用到。 LRU-K 没有被访问至 k 次的数据不会被缓存，淘汰时替换第 k 次访问距离现在最久的 page。 局部性 DBMS 跟踪一次 query 或事务中被访问的页，并决定移除哪些页。 优先级提示 由 DBMS 告诉 buffer pool 哪些 page 比较重要，从而使其保留下来。比如下图中，DBMS 应该知道插入时 0、4、6 三个索引页是一定要被访问到的。 如何处理脏页？ 如果移除脏页，则需要写回磁盘，io 效率低，可以在后台异步地将脏页写回。 ","date":"2022-10-22","objectID":"/cmu15445-%E7%BC%93%E5%86%B2%E6%B1%A0/:2:3","tags":["cmu15445"],"title":"cmu15445-缓冲池","uri":"/cmu15445-%E7%BC%93%E5%86%B2%E6%B1%A0/"},{"categories":null,"content":"other memory pools 排序+连接池 查询缓存 持久化池 日志池 字典缓存 ","date":"2022-10-22","objectID":"/cmu15445-%E7%BC%93%E5%86%B2%E6%B1%A0/:3:0","tags":["cmu15445"],"title":"cmu15445-缓冲池","uri":"/cmu15445-%E7%BC%93%E5%86%B2%E6%B1%A0/"},{"categories":null,"content":"课程大纲 自底向上依次介绍磁盘管理、缓冲池、访问方法、操作执行和查询计划。 ","date":"2022-10-21","objectID":"/cmu15445-storage/:1:0","tags":["cmu15445"],"title":"cmu15445-storage","uri":"/cmu15445-storage/"},{"categories":null,"content":"存储介质 非易失的 HDD 和 SSD、内存、CPU 缓存和寄存器。 ","date":"2022-10-21","objectID":"/cmu15445-storage/:2:0","tags":["cmu15445"],"title":"cmu15445-storage","uri":"/cmu15445-storage/"},{"categories":null,"content":"面向磁盘的数据库系统 ","date":"2022-10-21","objectID":"/cmu15445-storage/:3:0","tags":["cmu15445"],"title":"cmu15445-storage","uri":"/cmu15445-storage/"},{"categories":null,"content":"设计目标 存储超过内存大小的数据，同时兼顾读写性能。 ","date":"2022-10-21","objectID":"/cmu15445-storage/:3:1","tags":["cmu15445"],"title":"cmu15445-storage","uri":"/cmu15445-storage/"},{"categories":null,"content":"为什么不使用 mmap？ 多线程并发访问导致频繁的缺页中断 DBMS 想更好地控制内存及磁盘 以正确的顺序写脏页 特定的预读 buffer 替换 线程/进程调度 ","date":"2022-10-21","objectID":"/cmu15445-storage/:3:2","tags":["cmu15445"],"title":"cmu15445-storage","uri":"/cmu15445-storage/"},{"categories":null,"content":"数据库存储 ","date":"2022-10-21","objectID":"/cmu15445-storage/:4:0","tags":["cmu15445"],"title":"cmu15445-storage","uri":"/cmu15445-storage/"},{"categories":null,"content":"文件存储 数据库文件和操作系统中的其它文件没什么区别，存储引擎负责管理维护这些文件，以页的形式组织数据。 特点 一块数据，包括 tuples、元数据、索引和日志等等 每页有一个 id 组织结构 heap file 链式结构 页目录 ","date":"2022-10-21","objectID":"/cmu15445-storage/:4:1","tags":["cmu15445"],"title":"cmu15445-storage","uri":"/cmu15445-storage/"},{"categories":null,"content":"页格式 header header 中包含页的大小、校验和、DBMS 版本、事务的可见性、压缩信息 tuple 存储 存储格式 定长顺序存储 slotted pages log-structured 以日志形式组织数据需要定期合并和压缩数据 ","date":"2022-10-21","objectID":"/cmu15445-storage/:4:2","tags":["cmu15445"],"title":"cmu15445-storage","uri":"/cmu15445-storage/"},{"categories":null,"content":"tuple 格式 header 可见性信息，用于并发控制 空值的 bitmap 不存放 schema 信息 data 去规格化 关联的数据存在一起 record id page_id+offset/slot 对上层应用而言没有任何含义 ","date":"2022-10-21","objectID":"/cmu15445-storage/:4:3","tags":["cmu15445"],"title":"cmu15445-storage","uri":"/cmu15445-storage/"},{"categories":null,"content":"数据表示 ","date":"2022-10-21","objectID":"/cmu15445-storage/:5:0","tags":["cmu15445"],"title":"cmu15445-storage","uri":"/cmu15445-storage/"},{"categories":null,"content":"可变精度数据 float/real/double 使用原生 C/C++类型，IEEE-754 相比任意精度更快，但是会有舍入错误 ","date":"2022-10-21","objectID":"/cmu15445-storage/:5:1","tags":["cmu15445"],"title":"cmu15445-storage","uri":"/cmu15445-storage/"},{"categories":null,"content":"固定精度数据 numeric/decimal ","date":"2022-10-21","objectID":"/cmu15445-storage/:5:2","tags":["cmu15445"],"title":"cmu15445-storage","uri":"/cmu15445-storage/"},{"categories":null,"content":"大值存储 overflow page - external file - DBMS 不能操作外部文件 - 没有持久性和事务保证 ","date":"2022-10-21","objectID":"/cmu15445-storage/:5:3","tags":["cmu15445"],"title":"cmu15445-storage","uri":"/cmu15445-storage/"},{"categories":null,"content":"系统目录 存放数据库元数据 表、列属性、索引、视图、用户权限、统计信息 ","date":"2022-10-21","objectID":"/cmu15445-storage/:6:0","tags":["cmu15445"],"title":"cmu15445-storage","uri":"/cmu15445-storage/"},{"categories":null,"content":"存储模型 ","date":"2022-10-21","objectID":"/cmu15445-storage/:7:0","tags":["cmu15445"],"title":"cmu15445-storage","uri":"/cmu15445-storage/"},{"categories":null,"content":"数据库负载 OLTP 读/写少量数据 OLAP 复杂查询，读大量数据 HTAP OLTP+OLAP ","date":"2022-10-21","objectID":"/cmu15445-storage/:7:1","tags":["cmu15445"],"title":"cmu15445-storage","uri":"/cmu15445-storage/"},{"categories":null,"content":"数据模型 NSM 行存储，适用于 OLTP 应用 插入、更新和删除以及小范围查询效率高 整表查询浪费 io DSM 列存储，适用于 OLAP 应用 高效的 io 点查、插入、更新和删除时效率较低 tuple id 定长偏移量 每个属性的值都是定长的 嵌入式 id 每个值对应一个 id ","date":"2022-10-21","objectID":"/cmu15445-storage/:7:2","tags":["cmu15445"],"title":"cmu15445-storage","uri":"/cmu15445-storage/"},{"categories":null,"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. ","date":"0001-01-01","objectID":"/hello-world/:0:0","tags":null,"title":"Hello World","uri":"/hello-world/"},{"categories":null,"content":"Quick Start ","date":"0001-01-01","objectID":"/hello-world/:1:0","tags":null,"title":"Hello World","uri":"/hello-world/"},{"categories":null,"content":"Create a new post $ hexo new \"My New Post\" More info: Writing ","date":"0001-01-01","objectID":"/hello-world/:1:1","tags":null,"title":"Hello World","uri":"/hello-world/"},{"categories":null,"content":"Run server $ hexo server More info: Server ","date":"0001-01-01","objectID":"/hello-world/:1:2","tags":null,"title":"Hello World","uri":"/hello-world/"},{"categories":null,"content":"Generate static files $ hexo generate More info: Generating ","date":"0001-01-01","objectID":"/hello-world/:1:3","tags":null,"title":"Hello World","uri":"/hello-world/"},{"categories":null,"content":"Deploy to remote sites $ hexo deploy More info: Deployment ","date":"0001-01-01","objectID":"/hello-world/:1:4","tags":null,"title":"Hello World","uri":"/hello-world/"}]