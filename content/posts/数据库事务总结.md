---
title: "数据库事务总结"
date: 2023-10-01T11:45:58+08:00
draft: true
---

## ACID
ACID四个性质中，最为关键是原子性和隔离性，原子性保证事务要么全部成功，要么全部失败，隔离性控制事务做出的修改对于另一个事务的可见性。一致性需要以来应用层的逻辑保证数据库约束不被破坏，而持久性依赖于磁盘本身的特性。

## 隔离级别与读写异常
- RU，RC，RR，Serializable
- 脏读、脏写、读偏斜、幻象

## 2PL
### 基本思路
扩张阶段只能加锁，收缩阶段只能解锁。如果是strong-2pl，互斥锁的释放需要延迟到事务提交以后。
### 死锁预防
wait-die: 非抢占式，新事务等待，老事务死亡
wound-wait: 抢占式，新事务抢占，老事务等待
### 死锁检测与恢复
构建等待图，如果有环说明存在死锁。选择牺牲者并回滚进行死锁恢复，需要防止饥饿。
### 谓词锁与索引锁
谓词锁不属于某个对象，会精确地封锁住一个查询范围，阻塞对于这个区间内数据的操作，但是检测数据是否属于设置的区间时耗时的；更好的方法是使用索引锁，直接锁住索引上的一个范围，最终在更新索引的时候如果发生了冲突，便可以回滚事务。

## T/O
### 基本思路
- 读取数据的时候比较当前时间戳和数据写入时间戳，若写入时间戳大于当前时间戳，说明本应该读取的数据已经被新事务覆盖，此时应回滚
- 写入数据的时候，若当前事务的时间戳小于被写入数据的时间戳，则说明即将写入的数据是过时的，应回滚；若写入数据的时间戳小于其读取时间戳，说明该数据应该在过去写入，应回滚
- 使用T/O不会产生死锁，但是可能会出现饥饿
### 托马斯写规则
- 读取规则保持不变
- 写入数据的时候，如果当前事务的时间戳小于写入时间戳，则忽略该写入，事务无需回滚，实现视图隔离级别

## OCC
### 基本思路
维护私有的工作空间，在读阶段将读写操作写入read set和write set中，但是更新并不会写入数据库，在这之后进行校验，校验成功后进行写入。另一个重要思想是，对于事务$T_i$，$T_j$，若$T_i$先于$T_j$进行校验，则需要保证两事务的执行结果等价于$<T_i, T_j>$的串行化执行结果。
具体的校验分为以下三种情况：
- $T_i$的提交在$T_j$开始之前，这种情况下显然是串行化的
- $T_i$的提交在$T_j$写阶段之前，需要保证$T_i$的写不影响$T_j$的读，因此$Writeset(T_i) \cap Readset(T_j) = \emptyset$
- $T_i$的读在$T_j$之前完成读阶段（$T_i$的写可能发生在$T_j$之后），需要保证$Writeset(T_i) \cap Readset(T_j) = \emptyset$且$Writeset(T_i) \cap Writeset(T_j) = \emptyset$
<div align="center"><img src="/数据库事务总结/occ.png" style="zoom:75%;" /></div>

## MVCC
### 基本思路
#### 数据读取
维护活跃事务列表，根据事务的隔离级别判断应该读取哪个版本，比如RR级别，只能读取已经提交的比自己老的事务。
#### 数据写入
通过记录事务创建和修改时的时间戳和上一个（下一个）版本的指针，以链表的形式串联一个数据的多个版本。
#### 垃圾回收
回收终止事务的版本或者不会被任何活跃事务所访问的版本，垃圾回收可以由后台线程执行，也可以在数据查询的过程中或者事务提交的时候完成。垃圾回收往往需要根据当前最老的事务时间戳和数据被修改的时间戳进行全表扫描。

### 问题
由于MVCC对于数据的写入是并发的，因此可能存在更新丢失和写偏斜的问题。
#### 更新丢失
在数据更新/提交阶段，判断数据是否已经被其他事务修改，如果已经被修改，则应终止事务。
如果在数据更新阶段做判断，需要额外对数据上写锁。
#### 写偏斜
更新数据需要一定条件，在两个并发事务同时更新的瞬间条件满足，更新后发现条件并不满足了。
### SSI
- 检测是否读取了过期的对象
<div align="center"><img src="/数据库事务总结/ssi-1.png" style="zoom:50%;" /></div>
- 检测写是否影响了之前的读
<div align="center"><img src="/数据库事务总结/ssi-2.png" style="zoom:50%;" /></div>

### 配合其它并发控制手段使用

## 如何实现弱隔离级别